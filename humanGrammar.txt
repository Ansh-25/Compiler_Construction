<program>  -> <moduleDeclarations> <otherModules><driverModule><otherModules> 
<moduleDeclarations> -> <moduleDeclaration><moduleDeclarations> | ε 
<moduleDeclaration> -> DECLARE MODULE ID SEMICOL
<otherModules> -> <module><otherModules>| ε 
<driverModule> -> DRIVERDEF DRIVER  PROGRAM DRIVERENDDEF <moduleDef>
<module>  -> DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret><moduleDef> 
<ret>   -> RETURNS   SQBO <output_plist> SQBC SEMICOL | ε 
<input_plist> -> ID COLON <dataType> <_input_plist>
<_input_plist> -> COMMA ID COLON <dataType> <_input_plist> | ε
<output_plist> -> ID COLON <type> <_output_plist>
<_output_plist> -> COMMA ID COLON <type> <_output_plist> | ε
<dataType> -> INTEGER | REAL | BOOLEAN | ARRAY SQBO <range_arrays> SQBC OF <type>
<range_arrays> -> <index_arr> RANGEOP <index_arr> 
<type> -> INTEGER | REAL | BOOLEAN
<moduleDef> -> START <statements> END
<statements> -> <statement> <statements> | ε
<statement> -> <ioStmt>|<simpleStmt>|<declareStmt>|<conditionalStmt>|<iterativeStmt>
<ioStmt>GET_VALUE BO ID BC SEMICOL | PRINT BO <var_print> BC SEMICOL
<var_print> ID <P1> | NUM | RNUM | <boolConstt>
<boolConstt> TRUE | FALSE 
<P1>  SQBO <new_index> SQBC | ε
<simpleStmt>  -> <assignmentStmt> | <moduleReuseStmt> 
<assignmentStmt> -> ID <whichStmt> 
<whichStmt>   -><lvalueIDStmt> | <lvalueARRStmt> 
<lvalueIDStmt> -> ASSIGNOP <expression> SEMICOL
<lvalueARRStmt>  SQBO <element_index_with_expressions> SQBC ASSIGNOP <expression> SEMICOL
<index_arr> <sign><new_index>
<new_index>  NUM | ID
<sign> PLUS | MINUS | ε 
<moduleReuseStmt> <optional> USE MODULE ID WITH PARAMETERS <idList>SEMICOL
<optional>  SQBO <idList> SQBC ASSIGNOP | ε
<output_plist> ID <N3>
<N3>  COMMA ID <N3> | ε
<expression><arithmeticOrBooleanExpr> | <U>
<U>  <unary_op> <new_NT>
<new_NT>  BO <arithmeticExpr> BC | <var_id_num> 
<unary_op>  PLUS | MINUS 
<arithmeticOrBooleanExpr> <AnyTerm> <N7>
<N7>  <logicalOp> <AnyTerm> <N7> | ε
<AnyTerm> <arithmeticExpr> <N8> | <boolConstt> <N8>
<N8>  <relationalOp> <arithmeticExpr><N8> | ε
<arithmeticExpr> <term> <N4>
<N4>  <op1> <term> <N4> | ε
<term>  <factor> <N5>
<N5>  <op2> <factor> <N5>| ε
<factor>  NUM | RNUM | <boolConstt> | ID <N_11>
<N_11>  SQBO <element_index_with_expressions> SQBC | ε
<element_index_with_expressions> <sign> <N_10> | <arrExpr>
<N_10>  <new_index> | BO <arrExpr> BC 
<arrExpr> <arrTerm> <arr_N4>
<arr_N4>  <op1> <arrTerm> <arr_N4> | ε
<arrTerm>  <arrFactor> <arr_N5>
<arr_N5>  <op2> <arrFactor> <arr_N5>| ε 
<arrFactor>  <id_num_rnum> | <boolConstt> | BO <arrExpr> BC 
<op1>PLUS|MINUS 
<op2>MUL|DIV
<logicalOp> AND | OR
<relationalOp>  LT | LE | GT | GE | EQ | NE
<declareStmt>  DECLARE <idList> COLON <dataType> SEMICOL
<condionalStmt> SWITCH BO ID BC START <caseStmts><default> END 
<caseStmts>  CASE <value> COLON <statements> BREAK SEMICOL <N9>
<N9>  CASE <value> COLON <statements> BREAK SEMICOL <N9> | ε
<value> NUM | TRUE | FALSE
<default> DEFAULT COLON <statements> BREAK SEMICOL | e
<iterativeStmt> FOR BO ID IN <range_for_loop> BC START <statements> END | WHILE BO <arithmeticOrBooleanExpr> BC START <statements> END
<range_for_loop> <index_for_loop> RANGEOP <index_for_loop>
<index_for_loop> <sign_for_loop><new_index_for_loop>
<new_index_for_loop >  NUM
<sign_for_loop > PLUS | MINUS | ε

















