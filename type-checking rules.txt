//we can have a program symbol table, with each entry in the program ST pointing to a module ST
//each entry in the module ST points to either an ID or an ARR, each pointing to its type expression

<program> -> <module> ... <driverModule> ... <module> {
	createProgramTable PST;
	//for each module in the list
		PST.add(ST);
}
<module> -> ID <input_plist> <output_plist> <statements>
<input_plist> -> ID <dataType> ... {
	createSymbolTable ST;
	//traverse through each ID in the input list
		if(<dataType>!= Array) ST.addEntry(ID, <dataType>);
		else ST.addEntry(ID,<dataType>.<_type>, range);
}
<output_plist> -> ID <_type> ... {
	//traverse through each ID in the output list
		if(ST[ID] != <_type> {//return error}
}

<statement> -> ID ASSIGNOP <expression> {
	//same for both lvalueIDStmt and lvalueARRStmt
	if(ST[ID] != <expression>.dataType) return error

	//for lvalueARRStmt this extra line: 
	if (<element_index_with_expressions>.dataType != NUM) report error
} 

//for module reuse stmt {
	//for each paramater in the list
		//moduleID -> name of module
		//ID -> ID used in the function call
		//ID' -> corresponding parameter in the function declaration
		if(PST[moduleID][ID]!=ST[ID']) return error
}

//since we're doing this on the AST, I'll explain the next parts by word. Next parts are the expression AST part

//first we take it as if there are no array elements being used here
//in each of the nodes, be it +,-,*,/,<,>... we check the datatype of the 2 children nodes
//if they are not equal, throw an error
/if they are equal, then pass this datatype into the AST node. Then continue up (basically do bottom-up traversal)

//the answer is : 
//is integer, if both expressions are of type integer and the operator is an arithmetic operator PLUS, MINUS or MUL.
//is real, if both expressions are of type integer, or one is integer and the other is real, or both are real, and the operator is an arithmetic operator DIV.
//is real, if both the expressions are of type real and the operator is arithmetic operator PLUS, MINUS or MUL.
//is boolean, if both expressions are of type integer and the operator is a relational operator
//is boolean, if both expressions are of type real and the operator is relational.
//is boolean, if both expressions are of type boolean and the operator is logical.

The type of the expression is ERROR, if the above rules do not derive the type of E appropriately.


//now incorporating array indexes
//make sure the <element_index_with_expression> datatype is always NUM(since that's all that can be passed into an array
//the subtree for the element index follows the same rules as above
//cannot directly add arrays

<declareStmt> -> IDlist <dataType> {
	//for every ID in IDlist
		if(<dataType>!= Array) ST.addEntry(ID, <dataType>);
		else ST.addEntry(ID,<dataType>.<_type>, range);
}

//for conditional statement {
	//for every case stmt
		//ID is variable in SWITCH ID () ...
		//value is variable in CASE (value) ...
		if(ST[ID] != ST(value)) return error
}

<iterativeStmt> FOR BO ID IN <range_for_loop> BC START <statements> END {
	if(ST[ID] != <range_for_loop>.dataType) return error
}
<iterativeStmt> WHILE BO <arithmeticOrBooleanExpr> BC START <statements> END {
	<if(<arithmeticOrBooleanExpr>.dataType != BOOL) return error
}
<range_for_loop> <index_for_loop>1 RANGEOP <index_for_loop>2 {
	if(ST[<index_for_loop>1] != ST[<index_for_loop>2]) return error
	<range_for_loop>.dataType = <index_for_loop>1.dataType;
}
