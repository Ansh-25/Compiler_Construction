
GLobal:
grammar (array of linkedlist of heads of linkedlists(where each linkedlist is RHS of a rule))
first sets (array of linkedLists)
follow sets (Array of linkedLists)
Synchronising set (array of sets)
Stack S of nodes
Array[Array[TreeNode]] of size(nonTerminals * terminals)

TreeNode (Struct consisting of 
    nodeType
    rule no. (if non-terminal)
    Token (if terminal)
    link to children
    link to sibling
)
Stack node (
    link to corresponding TreeNode
)


//derivesEpsilon should be an O(1) operation (can be done by modifying the linkedListNodes)
void createSynchronizingSet(){
    create array of sets
    for(int i=0; i<followSet.size(); i++) {
        traverse through linkedList of that specific non-terminal
            array[i].add(followSet[i].val); //adding the element of that followset to the synchronising set
    }
    //rest is hardcoding
}

TreeNode* parse() {
    Initialize TreeNode Root with Program;
    TreeNode X = program;
    S.push(X);
    L = getNextToken();
    while(L!=null) {
        if(S.empty()==true) {
            reportError;
            break;
        }
        X = S.top().
        if(X.nodeType==terminal){
            if(X.token.Type==L.Type) {X.t = TERMINAL; X.val.t = L; S.pop(); L=getNextToken();}
            else {
                S.pop();
            };
        }
        else if(X.nodeType==nonTerminal){
            if(T[X,L]>=0) {X.treeNode.child=T[X,L]; X.ruleNo = ruleNo; S.pop(); S.pushRule(T[X,L]);} //pushRule pushes the rule in such that first char is at top of Stack
            else if(SynchronizingSet[X].contains(L)){
                S.pop();
            }
            else{L=getNextToken();}
        }
        else continue;
    }
    if S.empty()==false reportError;
    return Root;
}

computefirstandfollow {
    for all non terminals t:
        computefirst(t);
    for all non terminals t:
        computefollow(t);
}

void computeFirst (non terminal A)
{
    if first[A]!=null return;
    go through each rule in for that non-terminal
        if first is terminal, 
            add the terminal to first[A];
        if first is non terminal B
            computeFirst (B)
            add everything in first(B) to first(A) except epsilon
            while (derivesepsilon(B)) {
                B -> next(B) in the same rule
                if (isNullB) {
                    add epsilon
                    break;
                }
                else if (B is terminal)
                    add terminal to first set
                else {
                    computeFirst(B)
                    add everything from first[B] to first[A]
                }
            }
            check next term/non term
    return;
}

first[0] 

void computeFollow(nonTerminal A) {
    if Follow[A]!=null return;
    go through all rules of all grammar and encounter A. Keep track of LHS while going through the rules
        if next char after A is terminal {Follow[A].add(terminal)}
        else if(next char after A is non-terminal B) {
            add everything in first(B) to follow(A) except epsilon
            while (derivesepsilon(B)) {
                B -> next(B) in the same rule
                if (isNullB) {
                    computeFollow[LHS];
                    add follow[LHS];
                    break;
                }
                else if (B is terminal)
                    add terminal to follow set
                else {
                    computeFirst(B)
                    add everything from first[B] to follow[A]
                }
            }
        }
}

void createTable() {

    Initialise parse table with -2;
    For every production rule R {
        A = R -> head
        B = R -> head
        do {
            B = B -> next;
            if (B == NULL || B == epsilon) {
                for every terminal t in follow[A] add R to T[A,t]
                break;
            }
            if (B is a terminal) add R in T[A,B]
            else for every terminal t(!=epsilon) in first[B] add R to T[A,t]            
        }while (derivesEpsilon(B))
    }
}

int derivesEpsilon(int index) {
    iterate throught the linked list and check if epsilon is present in it
}
