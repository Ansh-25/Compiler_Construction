Nikhil
<program> <moduleDeclarations> <otherModules> <driverModule> <otherModules>
<moduleDeclarations> <moduleDeclaration> <moduleDeclarations>
<moduleDeclarations> EPS
<moduleDeclaration> DECLARE MODULE ID SEMICOL
<otherModules> <module> <otherModules>
<otherModules> EPS
<driverModule> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF <moduleDef>
<module> DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret> <moduleDef>
<ret> RETURNS SQBO <output_plist> SQBC SEMICOL
<ret> EPS
<input_plist> ID COLON <dataType> <_input_plist>
<_input_plist> COMMA ID COLON <dataType> <_input_plist>
<_input_plist> EPS
<output_plist> ID COLON <_type> <_output_plist>
<_output_plist> COMMA ID COLON <_type> <_output_plist>
<_output_plist> EPS
<dataType> INTEGER
<dataType> REAL
<dataType> BOOLEAN
<dataType> ARRAY SQBO <range_arrays> SQBC OF <_type>
<range_arrays> <index_arr> RANGEOP <index_arr>
<_type> INTEGER
<_type> REAL
<_type> BOOLEAN
<declareStmt> DECLARE <idList> COLON <dataType> SEMICOL
<moduleDef> START <statements> END
<statements> <statement> <statements>
<statements> EPS
<statement> <ioStmt>
<statement> <simpleStmt>
<statement> <declareStmt>
<statement> <conditionalStmt>
<statement> <iterativeStmt>

Toshit
<ioStmt> GET_VALUE BO ID BC SEMICOL {
	<ioStmt>.addr = ID.addr //post;keeps only i/p val
	free(GET_VALUE) free(BO) free(BC) free(SEMICOL)
}
<ioStmt> PRINT BO <var_print> BC SEMICOL {
	<ioStmt>.addr = <var_print>.addr //post
	free(PRINT) free(BO) free(BC) free(SEMICOL)
}
<var_print> ID <P1> {
	<var_print>.addr = makeNode(PRINT_ARR,ID.addr,P1.addr)
	free(P1)
}
<var_print> NUM {
	<var_print>.addr = NUM.addr
}
<var_print> RNUM {
	<var_print>.addr = RNUM.addr
}
<var_print> <boolConstt> {
	<var_print>.addr = <boolConstt>.addr
	free(boolConstt)
}
<boolConstt> TRUE {
	<boolConstt>.addr = TRUE.addr
}
<boolConstt> FALSE {
	<boolConstt>.addr = FALSE.addr
}
<P1> SQBO <index_arr> SQBC {
	<P1>.addr = <index_arr>.addr
	free(index_arr)
}
<P1> EPS {
	<P1>.addr = NULL
	free(EPS)
}
<simpleStmt> <assignmentStmt> {
	<simpleStmt>.addr = <assignmentStmt>.syn_addr
	free(assignmentStmt)
}
<simpleStmt> <moduleReuseStmt> {
	<simpleStmt>.addr = <moduleReuseStmt>.syn_addr
	free(moduleReuseStmt)
}
<assignmentStmt> ID <whichStmt> {
	<assignmentStmt>.addr = ID.addr
	<whichStmt>.inh_addr = <assignmentStmt>.addr
	<assignmentStmt>.syn_addr = <whichStmt>.syn_addr
	free(whichStmt)
}
<whichStmt> <lvalueIDStmt> {
	<lvalueIDStmt>.inh_addr = <whichStmt>.inh_addr
	<whichStmt>.syn_addr = <lvalueIDStmt>.addr
	free(lvalueIDStmt)
}
<whichStmt> <lvalueARRStmt> {
	<lvalueARRStmt>.inh_addr = <whichStmt>.inh_addr
	<whichStmt>.syn_addr = <lvalueARRStmt>.addr
	free(lvalueARRStmt)
}
<lvalueIDStmt> ASSIGNOP <expression> SEMICOL {
	<lvalueIDStmt>.addr = makeNode(ASSIGNOP,<lvalueIDStmt>.inh_addr,<expression>.addr,NULL)
	free(ASSIGNOP)
	free(SEMICOL)
}
<lvalueARRStmt> SQBO <element_index_with_expressions> SQBC ASSIGNOP <expression> SEMICOL {
	<lvalueIDStmt>.addr = makeNode(ASSIGNOP,<lvalueIDStmt>.inh_addr,<element_index_with_expressions>.addr,<expression>.addr,NULL)
	free(SQBO) free(SQBC)
	free(ASSIGNOP)
	free(SEMICOL)
}
<index_arr> <sign> <new_index> {
	<index_arr>.addr = makeNode(INDEX_ARR,<sign>.addr,<new_index>.addr)
	free(sign)
	free(new_index)
}
<new_index> NUM {
	<new_index>.addr = NUM.addr
}
<new_index> ID {
	<new_index>.addr = ID.addr
}
<sign> PLUS {
	<sign>.addr = PLUS.addr
}
<sign> MINUS {
	<sign>.addr = MINUS.addr
}
<sign> EPS {
	<sign>.addr = NULL
	free(EPS)
}
<moduleReuseStmt> <optional> USE MODULE ID WITH PARAMETERS <actual_para_list> SEMICOL {
	<moduleReuseStmt>.syn_addr = <actual_para_list>.addr
	<actual_para_list>.inh_addr = ID.addr
	<optional>.inh_addr = <moduleReuseStmt>.syn_addr
	<moduleReuseStmt>.addr = <optional.addr>
	free(USE,MODULE,WITH,PARAMETERS,SEMICOL)
}
<actual_para_list> <K> <N_12> {
	<actual_para_list>.syn_list = insertAtFront(<N_12>.syn_list,<K>.addr)
	<actual_para_list>.addr = makeNode(MODULE,<actual_para_list>.inh_addr,<actual_para_list>.syn_list)
}
<actual_para_list> <sign> <K> <N_12> {
	<actual_para_list>.syn_list = insertAtFront(<N_12>.syn_list,<sign>.addr,<K>.addr)
	<actual_para_list>.addr = makeNode(MODULE,<actual_para_list>.inh_addr,<actual_para_list>.syn_list)
}
<N_12> COMMA <sign> <K> <N_12> {
	<N_12>.syn_list = insertAtFront(<N_12>1.syn_list,<sign>.addr,<K>.addr)
}
<N_12> EPS {
	<N_12>.syn_list = NULL
}
<K> NUM {
	<K>.addr = NUM.addr
}
<K> RNUM {
	<K>.addr = RNUM.addr
}
<K> <boolConstt> {
	<k>.addr = <boolConstt>.addr
	free(boolConstt)
}
<K> ID <N_11> {
	<K>.addr = insertAtFront(<N_11>.syn_list, ID.addr)
}
<optional> SQBO <idList> SQBC ASSIGNOP {
	optional.addr = makeNode(ASSIGNOP,<idList>.addr, <optional>.inh_addr) //assignop,lhs_addr, rhs_addr
	free(SQBO,SQBC,ASSIGNOP)
}
<optional> EPS {
	<optional>.addr = NULL
	free(EPS)
}
<idList> ID <N3> {
	<idList>.addr = insertAtFront(<N3>.syn_list,ID.addr)
	free(N3)
}
<N3> COMMA ID <N3> {
	<N3>.syn_list = insertAtFront(<N3>1.syn_list,ID.addr)
	free(COMMA)
	free(<N3>1)
}
<N3> EPS {
	<N3>.syn_list = NULL;
}

Ansh
<expression> <arithmeticOrBooleanExpr>
<expression> <U>
<U> <unary_op> <new_NT>
<new_NT> BO <arithmeticExpr> BC
<new_NT> <var_id_num>
<unary_op> PLUS 
<unary_op> MINUS
<var_id_num> ID
<var_id_num> NUM
<var_id_num> RNUM
<arithmeticOrBooleanExpr> <AnyTerm> <N7>
<N7> <logicalOp> <AnyTerm> <N7>
<N7> EPS
<AnyTerm> <arithmeticExpr> <N8>
<AnyTerm> <boolConstt>
<N8> <relationalOp> <arithmeticExpr>
<N8> EPS
<arithmeticExpr> <term> <N4>
<N4> <op1> <term> <N4>
<N4> EPS
<term> <factor> <N5>
<N5> <op2> <factor> <N5>
<N5> EPS
<factor> BO <arithmeticOrBooleanExpr> BC
<factor> NUM
<factor> RNUM
<factor> <boolConstt>
<factor> ID <N_11>
<N_11> SQBO <element_index_with_expressions> SQBC
<N_11> EPS
<element_index_with_expressions> <sign> <N_10>
<element_index_with_expressions> <arrExpr>
<N_10> <new_index>
<N_10> BO <arrExpr> BC
<arrExpr> <arrTerm> <arr_N4>
<arr_N4> <op1> <arrTerm> <arr_N4>
<arr_N4> EPS
<arrTerm> <arrFactor> <arr_N5>
<arr_N5> <op2> <arrFactor> <arr_N5>
<arr_N5> EPS
<arrFactor> ID
<arrFactor> BO <arrExpr> BC
<arrFactor> <boolConstt>
<arrFactor> NUM
<op1> PLUS
<op1> MINUS
<op2> MUL
<op2> DIV
<logicalOp> AND
<logicalOp> OR
<relationalOp> LT
<relationalOp> LE
<relationalOp> GT
<relationalOp> GE
<relationalOp> EQ
<relationalOp> NE

Shreekar
//format of makeNode function
//makeNode(type of node, value in the node, child node);

<conditionalStmt> SWITCH BO ID BC START <caseStmts> <_default> END  {
	<caseStmts>.inh_addr=ID.addr
	<_default>.inh_addr = <caseStmts>.end;
	<conditionalStmt> = <caseStmts>.addr;
	free(SWITCH); free(BO); free(BC); free(START); free(END);
}
<caseStmts> CASE <value> COLON <statements> BREAK SEMICOL <N9>  {
	<caseStmts>.addr = makeNode(SWITCH, <caseStmts>.inh_addr, makeNode(CASE,<value>.addr,<statements>.addr));
	<caseStmts>.addr->child->next = <N9>.syn_addr;
	if(<N9>.end==NULL) {<caseStmts>.end==<caseStmts>.addr;}
	else {<caseStmts>.end=<N9>.end;}
	free(CASE); free(COLON); free(BREAK); free(SEMICOL);
	//computed going bottom up
}
<N9> CASE <value> COLON <statements> BREAK SEMICOL <N9>1  {
	<N9>.syn_addr = makeNode(CASE,<value>.addr,<statements>.addr);
	<N9>.syn_addr->next = <N9>1.syn_addr;
	if(<N9>1.end==NULL) {<N9>.end==<N9>.syn_addr;}
	else {<N9>.end=<N9>1.end;}
	free(CASE); free(COLON); free(BREAK); free(SEMICOL);
	//computed going bottom up
}
<N9> EPS  {
	<N9>.syn_addr = NULL;
	<N9>.end=<N9.syn_addr>;
	free(EPS);
}
<value> NUM {
	<value.addr> = NUM.addr;
}
<value> TRUE {
	<value.addr> = TRUE.addr;
}
<value> FALSE {
	<value.addr> = FALSE.addr;
}
<_default> DEFAULT COLON <statements> BREAK SEMICOL  {
	<_default>.inh_addr->next=makeNode(DEFAULT,NULL,<statements>.addr);
	free(DEFAULT); free(COLON); free(BREAK); free(SEMICOL);
	//creates Default node
}
<_default> EPS  {
	<_default>.inh_addr->next=NULL;
	free(EPS);
}

<iterativeStmt> FOR BO ID IN <range_for_loop> BC START <statements> END {
	<iterativeStmt>.addr = makeNode(FOR,ID.addr,<range_for_loop>.left_addr);
	<iterativeStmt>.addr->child->next = <range_for_loop>.right_addr;
	<iterativeStmt>.addr->child->next->next = <statements>.addr;
	free(FOR); free(BO); free(BC); free(IN); free(START); free(END);
}
<iterativeStmt> WHILE BO <arithmeticOrBooleanExpr> BC START <statements> END {
	<iterativeStmt>.addr = makeNode(WHILE,NULL,<arithmeticOrBooleanExpr>.addr);
	<iterativeStmt>.addr->child-next = <statements>.addr;
	free(WHILE); free(BO); free(BC); free(START); free(END);
}
<range_for_loop> <index_for_loop>1 RANGEOP <index_for_loop>2 {
	<range_for_loop>.left_addr = <index_for_loop>1.addr;
	<range_for_loop>.right_addr = <index_for_loop>2.addr;
	free(RANGEOP);
}
<index_for_loop> <sign_for_loop> <new_index_for_loop> {
	<index_for_loop>.addr=makeNode(RANGENUM,<sign_for_loop>.addr,<new_index_for_loop>.addr);
}
<new_index_for_loop> NUM {
	<new_index_for_loop>.addr=NUM.addr;
}
<sign_for_loop> PLUS {
	<sign_for_loop>.addr=PLUS.addr;
}
<sign_for_loop> MINUS {
	<sign_for_loop>.addr=MINUS.addr;
}
