struct ListNode* synchronizingSet[NO_NONTERMS];

void createSynchronizingSet(){
    for(int i=0; i<NO_NONTERMS; i++) {
        struct ListNode* C = follow[i];
	struct ListNode* temp synchronizingSet[i];
	while(C!=NULL){
            ListNode* newnode = (ListNode *)malloc(sizeof(ListNode));
    	    newnode -> val = C->val;
    	    newnode -> next = NULL;
	    temp=newnode;
	    C=C->next;
	    temp=temp->next;
        }
    }
    //rest is hardcoding
}

type t;
int ruleno;
union treenodeval val;
struct TreeNode* child;
struct TreeNode* sibling;

//if (contains(synchronizingSet[5],L.type)) {/*do something*/}

int contains(ListNode* ln, tokentype term) {
    if (ln == NULL)
        return 0;
    for (ListNode* curr = ln; curr != NULL; curr = curr -> next) {
        if (curr -> val.t == TERMINAL && curr -> val.g.t == term)
            return 1;
    }
    return 0;
}

void pushRule(int rule, StackNode* S) {
	//find the LHS of the rule in the grammar
	struct ListNode* LHS = grammar[rule]->next;
	//create treenode of first grammarchar
	TreeNode* temp= (TreeNode*)malloc(sizeof(TreeNode));
	if(LHS->val.t==TERMINAL){
		temp->t=TERMINAL;
		temp->ruleno=rule;
		//temp->val.t = TK_EPS;
		temp->child = NULL;
		temp->sibling=NULL;
	}
	else {
		temp->t=NONTERMINAL;
		temp->ruleno=rule;
		temp->val.t = LHS->val.g.nt;
		temp->child = NULL;
		temp->sibling=NULL;
	}
	StackNode* auxilliary;
	//push pointer to a seperate stack
	push(auxilliary, temp);
	//child pointer of top of stack points to first grammarchar
	X->child=temp;
	//go through rest of LHS, creating treeNodes, pointing prev sibling pointer to it, pushing to stack and continue
	while(LHS->next!=NULL){
		TreeNode* nextNode = (TreeNode*)malloc(sizeof(TreeNode));
		if(LHS->next->val.t==TERMINAL){
			nextNode->t=TERMINAL;
			nextNode->ruleno=rule;
			//nextNode->val.t = TK_EPS;
			nextNode->child = NULL;
			nextNode->sibling=NULL;
		}
		else {
			nextNode->t=NONTERMINAL;
			nextNode->ruleno = rule;
			nextNode->val.t = LHS->next->val.g.nt;
			nextNode->child = NULL;
			nextNode->sibling=NULL;
		}
		temp->sibling = nextNode;
		push(auxilliary, nextNode);
		temp=temp->sibling;
		LHS=LHS->next;
	}
	//pop from auxilliary stack and push to main stack
	pop(S);
	while(isEmpty(auxilliary)==0){
		push(S,pop(auxilliary));
	}
}
