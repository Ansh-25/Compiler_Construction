<range>  {NUM}  {BC,SQBC}

<iterativeStmt>   {FOR,WHILE}  {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK}  //F=STAT

<default> {DEFAULT,E}

<value>  {NUM,TRUE,FALSE}  {COLON,}

<caseStmt> {CASE,E}  {DEFAULT,END}

<conditionalStmt> {SWITCH} {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK} //F=STAT

<declareStmt> {DECLARE} {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK}  //F=STAT

<relationalOp> {LT | LE | GT | GE | EQ | NE}  {BO,ID,NUM,RNUM}

<logicalOp> {AND,OR}  {BO,ID,NUM,RNUM}

<_booleanExpr> {AND,OR,E}  **{BC,AND,OR,SEMICOL}** //F=BOOLEAN

<booleanExpr>  {BO,ID,TRUE,FALSE,NUM,RNUM,}  **{BC,AND,OR,SEMICOL}**  //F=EXPR

<factor> {BO,ID,NUM,RNUM}  **{MUL,DIV, PLUS,MINUS,LT | LE | GT | GE | EQ | NE,AND,OR,BC,SEMICOL} ** //F=TERM

<mulop> {MUL,DIV}  {BO,ID,NUM,RNUM} 

<_term> {MUL,DIV,E}   **{PLUS,MINUS,LT | LE | GT | GE | EQ | NE,AND,OR,BC} **

<term> {BO,ID,NUM,RNUM}  **{PLUS,MINUS,LT | LE | GT | GE | EQ | NE,AND,OR,BC,SEMICOL} **  //F=ARITH

<addop> {PLUS,MINUS}  {BO,ID,NUM,RNUM}

<_arithmeticExpr> {PLUS,MINUS,E}  **{LT | LE | GT | GE | EQ | NE,AND,OR,BC}**

<arithmeticExpr> {PLUS,MINUS,BO,ID,NUM,RNUM}    **{LT | LE | GT | GE | EQ | NE,AND,OR,BC,SEMICOL}** //F=EXPR

<expression> {BO,ID,NUM,RNUM}  {SEMICOL}

<_idList> {COMMA,E}  {SQBC,SEMICOL}  //F=ID

<idList> {ID}  {COLON,} {SQBC,SEMICOL}

<optional> {SQBO,E}  {USE}

<moduleReuseStmt> {SQBO,E}  {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK} //F=SIMPLE

<index> {NUM,ID}  {SQBC}

<lvalueARRStmt> {SQBO}  {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK} //F=WHICHS

<lvalueIDStmt> {ASSIGNOP} {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK}  //F=WHICHS

<whichStmt> {SQBO,ASSIGNOP}  {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK}  //F=ASSIGN

<assignmentStmt> {ID}  {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK}  //F=SIMPLE

<simpleStmt> {ID,SQBO,E} {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK}  //F=STAT

<whichId> {SQBO,E}  {BC,MUL,DIV, PLUS,MINUS,LT | LE | GT | GE | EQ | NE,AND,OR,BC,SEMICOL}  //F=VAR

<var> {ID,NUM,RNUM} {BC,MUL,DIV, PLUS,MINUS,LT | LE | GT | GE | EQ | NE,AND,OR,BC,SEMICOL}  //F = FACTOR

<ioStmt> {GET_VALUE,PRINT}   {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK} //F=STAT

<statement> {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,E} {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,END,BREAK}

<statements> {GET_VALUE,PRINT,ID,SQBO,DECLARE,SWITCH,FOR,WHILE,E}  {END,BREAK,}

<moduleDef> {START}  {DEF,DRIVERDEF}   //F=MODULE,DRIVER

<type> {INTEGER | REAL | BOOLEAN}  {SEMICOL,COMMA,SQBC}  //F=DATATYPE,OUT

<dataType> {INTEGER | REAL | BOOLEAN,ARRAY}  {SEMICOL,COMMA,SQBC} //F=INP

<_output_plist> {COMMA,E} {SQBC}

<output_plist> {ID}  {SQBC}

<_input_plist> {COMMA,E} {SQBC}

<input_plist>  {ID} {SQBC}

<ret> {RETURNS,E} {START}

<module> {DEF}  {DEF,DRIVERDEF}  //F=OTHER

<driverModule> {DRIVERDEF}  {DEF} 

<otherModules> {DEF,E} {DRIVERDEF}

<moduleDeclaration> {DECLARE}  {DECLARE,DEF,DRIVERDEF}  //F=MODS

<moduleDeclarations> {DECLARE,E}  {DEF,DRIVERDEF}

<program> {DECLARE,E} {}





